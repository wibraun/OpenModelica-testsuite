// name: inlineArray3
// status: correct

// use new inline method
setCommandLineOption("+inlineMethod=append");

loadString("
model foo
  function f
    input Real[5] x;
    output Real[7] y;
  protected
    Real sumx = exp(-sqrt(sum(x)));
	Real tmpy;
  algorithm
    y[1] := sumx^2;
	y[2] := 2*sumx^2;
	y[3] := 3*sumx^2;
	y[4] := 4*sumx^2;
	y[5] := 5*sumx^2;
	y[6] := 6*sumx^2;
	tmpy := 7*sumx^2;
	y[7] := exp(-sqrt(tmpy/sum(y[i] for i in 1:6))/tmpy);
    annotation(Inline=true); 
  end f;
  
  Real y(fixed = true, start = 1);
  Real v(fixed = true, start = -1);
  Real h(start = 0);
protected
  Real[5] a;
  Real c;
  Real d;

  Real[5] x;
  Real[:] z = {i*sin(time) + 1 for i in 1:10};
  Real[5] w = {z[i]^i/sum(z) for i in 1:5}; 
equation
   x[1] = a[1] + a[2] + w[1];
   x[2] = z[1] + a[1];
   x[3] = z[2] + a[3] + a[1] + 2*a[2] + sum(z);
   x[4] = z[2] + a[3] + a[1] + 2*a[2];
   x[5] = z[2] + x[3] + a[1] + 2*a[2] + cos(sum(a)) + w[2];
   a[1] = sum(f(x))/10;
   a[2] = sum(f(z[1:5]))/10;
   a[3] = sum(f(z[6:10]))/10;
   a[4] = sum(f(z[2:6]))/10;
   a[5] = sum(f(z[3:7]))/10;
   c = exp(-sum(f(a))) - sum(w);
   d = sum(w);
   der(y) = sin(c) - cos(sum(f(x))) + sum(a)/10;
   der(v) = y - d;
   
   when sample(0,0.1) then
     h = v + y + sum(f(z[1:5]))/10 + sum(f(z[6:10]))/10;
   end when;
end foo;
");
getErrorString();

setCommandLineOptions("+d=dumpBackendInline");
getErrorString();
simulate(foo);
getErrorString();
val(h,{0,0.5,1.0}); // 0, -17.139// Result:
//
// true
// "[simulation/modelica/inlineFunction/inlineArray3.mos:5:1-5:45:writable] Error: Class setCommandLineOption not found in scope <global scope> (looking for a function or record).
// "
// true
// ""
//
// ############ BackendInline ############
// ########################################
// Result DAE after Inline. (1 partitions)
// ########################################
//
//
// unknown partition
// ========================================
//
// Variables (30)
// ========================================
// 1: w[5]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 2: w[4]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 3: w[3]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 4: w[2]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 5: w[1]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 6: z[10]:VARIABLE(protected = true ) .foo, .Real type: Real [10]
// 7: z[9]:VARIABLE(protected = true ) .foo, .Real type: Real [10]
// 8: z[8]:VARIABLE(protected = true ) .foo, .Real type: Real [10]
// 9: z[7]:VARIABLE(protected = true ) .foo, .Real type: Real [10]
// 10: z[6]:VARIABLE(protected = true ) .foo, .Real type: Real [10]
// 11: z[5]:VARIABLE(protected = true ) .foo, .Real type: Real [10]
// 12: z[4]:VARIABLE(protected = true ) .foo, .Real type: Real [10]
// 13: z[3]:VARIABLE(protected = true ) .foo, .Real type: Real [10]
// 14: z[2]:VARIABLE(protected = true ) .foo, .Real type: Real [10]
// 15: z[1]:VARIABLE(protected = true ) .foo, .Real type: Real [10]
// 16: x[5]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 17: x[4]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 18: x[3]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 19: x[2]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 20: x[1]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 21: d:VARIABLE(protected = true ) .foo, .Real type: Real
// 22: c:VARIABLE(protected = true ) .foo, .Real type: Real
// 23: a[5]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 24: a[4]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 25: a[3]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 26: a[2]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 27: a[1]:VARIABLE(protected = true ) .foo, .Real type: Real [5]
// 28: h:DISCRETE(start = 0.0 ) .foo, .Real type: Real
// 29: v:STATE(1)(start = -1.0 fixed = true ) .foo, .Real type: Real
// 30: y:STATE(1)(start = 1.0 fixed = true ) .foo, .Real type: Real
//
//
// Equations (17, 30)
// ========================================
// 1/1 (10): z = {1.0 + sin(time), 1.0 + 2.0 * sin(time), 1.0 + 3.0 * sin(time), 1.0 + 4.0 * sin(time), 1.0 + 5.0 * sin(time), 1.0 + 6.0 * sin(time), 1.0 + 7.0 * sin(time), 1.0 + 8.0 * sin(time), 1.0 + 9.0 * sin(time), 1.0 + 10.0 * sin(time)}   [dynamic]
// 2/11 (5): w = {z[1] / (z[1] + z[2] + z[3] + z[4] + z[5] + z[6] + z[7] + z[8] + z[9] + z[10]), z[2] ^ 2.0 / (z[1] + z[2] + z[3] + z[4] + z[5] + z[6] + z[7] + z[8] + z[9] + z[10]), z[3] ^ 3.0 / (z[1] + z[2] + z[3] + z[4] + z[5] + z[6] + z[7] + z[8] + z[9] + z[10]), z[4] ^ 4.0 / (z[1] + z[2] + z[3] + z[4] + z[5] + z[6] + z[7] + z[8] + z[9] + z[10]), z[5] ^ 5.0 / (z[1] + z[2] + z[3] + z[4] + z[5] + z[6] + z[7] + z[8] + z[9] + z[10])}   [dynamic]
// 3/16 (1): x[1] = a[1] + a[2] + w[1]   [dynamic]
// 4/17 (1): x[2] = z[1] + a[1]   [dynamic]
// 5/18 (1): x[3] = 2.0 * z[2] + a[3] + a[1] + 2.0 * a[2] + z[1] + z[3] + z[4] + z[5] + z[6] + z[7] + z[8] + z[9] + z[10]   [dynamic]
// 6/19 (1): x[4] = z[2] + a[3] + a[1] + 2.0 * a[2]   [dynamic]
// 7/20 (1): x[5] = z[2] + x[3] + a[1] + 2.0 * a[2] + cos(a[1] + a[2] + a[3] + a[4] + a[5]) + w[2]   [dynamic]
// 8/21 (1): a[1] = 0.1 * sum(foo.f({x[1], x[2], x[3], x[4], x[5]}))   [dynamic]
// 9/22 (1): a[2] = 0.1 * sum(foo.f({z[1], z[2], z[3], z[4], z[5]}))   [dynamic]
// 10/23 (1): a[3] = 0.1 * sum(foo.f({z[6], z[7], z[8], z[9], z[10]}))   [dynamic]
// 11/24 (1): a[4] = 0.1 * sum(foo.f({z[2], z[3], z[4], z[5], z[6]}))   [dynamic]
// 12/25 (1): a[5] = 0.1 * sum(foo.f({z[3], z[4], z[5], z[6], z[7]}))   [dynamic]
// 13/26 (1): c = exp(-sum(foo.f({a[1], a[2], a[3], a[4], a[5]}))) + (-w[2]) - w[1] - w[3] - w[5] - w[4]   [dynamic]
// 14/27 (1): d = w[1] + w[2] + w[3] + w[4] + w[5]   [dynamic]
// 15/28 (1): der(y) = sin(c) + 0.1 * (a[1] + a[2] + a[3] + a[4] + a[5]) - cos(sum(foo.f({x[1], x[2], x[3], x[4], x[5]})))   [dynamic]
// 16/29 (1): der(v) = y - d   [dynamic]
// 17/30 (1): when sample(1, 0.0, 0.1) then
//   h := v + y + 0.1 * (sum(foo.f({z[1], z[2], z[3], z[4], z[5]})) + sum(foo.f({z[6], z[7], z[8], z[9], z[10]})));
// end when;   [dynamic]
//
//
// Simple Equations (0, 0)
// ========================================
//
//
// State Sets
// ========================================
//
//
// Incidence Matrix (row: equation)
// ========================================
// number of rows: 17
// 1: 15 14 13 12 11 10 9 8 7 6
// 2: 6 7 8 9 10 11 12 13 14 15 5 4 3 2 1
// 3: 5 26 27 20
// 4: 27 15 19
// 5: 6 7 8 9 10 11 12 13 15 26 27 25 14 18
// 6: 26 27 25 14 17
// 7: 4 23 24 25 26 27 18 14 16
// 8: 16 17 18 19 20 27
// 9: 11 12 13 14 15 26
// 10: 6 7 8 9 10 25
// 11: 10 11 12 13 14 24
// 12: 9 10 11 12 13 23
// 13: 2 1 3 5 4 23 24 25 26 27 22
// 14: 1 2 3 4 5 21
// 15: 16 17 18 19 20 23 24 25 26 27 22 30
// 16: 21 -30 29
// 17: 6 7 8 9 10 11 12 13 14 15 -30 -29 28
//
// Transposed Incidence Matrix (row: variable)
// ========================================
// number of rows: 30
// 1: 14 13 2
// 2: 14 13 2
// 3: 14 13 2
// 4: 14 13 7 2
// 5: 14 13 3 2
// 6: 17 10 5 2 1
// 7: 17 10 5 2 1
// 8: 17 10 5 2 1
// 9: 17 12 10 5 2 1
// 10: 17 12 11 10 5 2 1
// 11: 17 12 11 9 5 2 1
// 12: 17 12 11 9 5 2 1
// 13: 17 12 11 9 5 2 1
// 14: 17 11 9 7 6 5 2 1
// 15: 17 9 5 4 2 1
// 16: 15 8 7
// 17: 15 8 6
// 18: 15 8 7 5
// 19: 15 8 4
// 20: 15 8 3
// 21: 16 14
// 22: 15 13
// 23: 15 13 12 7
// 24: 15 13 11 7
// 25: 15 13 10 7 6 5
// 26: 15 13 9 7 6 5 3
// 27: 15 13 8 7 6 5 4 3
// 28: 17
// 29: -17 16
// 30: -17 -16 15
//
// no matching
//
//
// record SimulationResult
//     resultFile = "foo_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 500, tolerance = 1e-06, method = 'dassl', fileNamePrefix = 'foo', options = '', outputFormat = 'mat', variableFilter = '.*', cflags = '', simflags = ''",
//     messages = ""
// end SimulationResult;
// "Warning: The initial conditions are not fully specified. Use +d=initialization for more information.
// Warning: There are iteration variables with default zero start attribute. Use +d=initialization for more information.
// "
// {0.04812243429093915,-2.749810335170805,-24.0237962665258}
// endResult
